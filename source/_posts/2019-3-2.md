---
title: react hooks
date: 2019-03-02 19:07:12
tags: [hooks]
categories: [react]
---

react hooks 已随`react 16.8`发布, 做一些简单的测试

### 常用

1. useState

```js
import React, { useState } from 'react'

export default () => {
    // 第一个参数为属性, useState 传入参数为初始值
    // 第二个参数 setStatus, 与status配对, 用于更新此属性, 无需使用{status}, 只需要传输更新的值
    const [count, setCount] = useState(0)

    // 多次声明多个属性
    const initObj = {
        text: 'init',
        changed: false,
    }
    const [objectData, setObjectData] = useState(initObj)

    // 状态 及 更新函数 可直接使用
    return <div>
        <div>
            <Button onClick={() => {setCount(count + 1)}}>add</Button>
            <span>{count}</span>
        </div>
        <div>
            <Button
                onClick={() => {
                    setObjectData(preData => {
                        const newData = {
                            text: 'new',
                            changed: true,
                        }
                        // 对象数据需要全量更新
                        return {...preData, ...newData}
                    })
                }}
            >
                change objectData
            </Button>
            <span style={{ marginLeft: '20px' }}>{objectData.text}</span>
        </div>
    </div>
}
// ...
```

<!-- more -->
2. useEffect

```js
import React, { useState, useEffect } from 'react'

export default () => {
    const [count] = useState(0)

    // 可以把 useEffect 理解为 componentDidMount, componentDidUpdate, componentWillUnmount 的整合.
    // 每次 render 后调用
    // 并不会阻塞页面

    // 按类型分为两种:

    // 1. 不需要清理的 eg: 网络请求, dom操作, 日志等
    useEffect(() => {
        // 等同于 componentDidMount + componentDidUpdate 中执行
        console.log('count: ', count);
    })

    // 2.需要清理的 事件订阅等
    useEffect(() => {
        console.log('bind event "btnClick"');
        eventProxy.on('btnClick', handleClick)

        // 可以理解为 componentWillUnmount 后执行回调
        return () => {
            console.log('clear event "btnClick"');
            eventProxy.off('btnClick')
        }
    },[])
    // useEffect 第二个参数用于控制执行时机, 参数类型为数组
    // 不传时在每次 render 都会执行一遍, 处理事件订阅不合适
    // 如果传入值, 则根据其更新来执行
    // 如果传空数组([]), 只会在 `挂载` 和 `卸载` 时执行

    function handleClick() {
        console.log('on Click');
    }

    return (
        <div>
            <div>
                <Button
                    onClick={() => {
                        eventProxy.trigger('btnClick')
                    }}
                >
                    eventProxy trigger
                </Button>
            </div>
        </div>
    )
}
```

3. useContext

```js
import React, { useState, useEffect, useContext } from 'react'

import { Button } from 'antd'

const ThemeContext = React.createContext('dark')

interface EventHandle {
    (): void
}
interface UserProps {
    onClick: EventHandle
}
interface ContainerState {
    theme: string
}

const ContextUser = ({ onClick }: UserProps) => {

    // useContext 传入 context, 即可直接使用其 value
    const context:string = useContext(ThemeContext)

    return (
        <div>
            <div>
                <Button onClick={onClick}>change theme</Button>
                <span style={{ marginLeft: '20px' }}>context: {context}</span>
                {/* 对比之前用法 */}
                {/* <ThemeContext.Consumer>
                    {theme => <span style={{ marginLeft: '20px' }}>{theme}</span>}
                </ThemeContext.Consumer> */}
            </div>
        </div>
    )
}

class UseContextContainer extends React.Component {
    readonly state: ContainerState = {
        theme: 'dark',
    }

    toggleTheme = () => {
        this.setState(({ theme }:ContainerState) => ({ theme: theme === 'dark' ? 'light' : 'dark' }))
    }

    render() {
        return (
            <div>
                <ThemeContext.Provider value={this.state.theme}>
                    <ContextUser onClick={this.toggleTheme} />
                </ThemeContext.Provider>
            </div>
        )
    }
}

export default UseContextContainer
```

### [Additional Hooks](https://reactjs.org/docs/hooks-reference.html#additional-hooks)

> The following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.

1. useReducer

类比 redux
```js
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

2. useCallback

可以做到 shouldComponentUpdate 控制渲染, 待实践

1. useMemo

> useCallback(fn, inputs) is equivalent to useMemo(() => fn, inputs).

2. useRef

> 同类组件获取元素

```js 官网示例
function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
        // `current` points to the mounted text input element
        inputEl.current.focus();
    };
    return (
        <>
            <input ref={inputEl} type="text" />
            <button onClick={onButtonClick}>Focus the input</button>
        </>
    );
}
```

1. useImperativeHandle

ref 父子组件, 传递相关

2. useLayoutEffect

    - useEffect 不会阻塞页面, 但是有些 dom 操作等需要立即执行时, 就不合适了
    - useLayoutEffect 会保持和生命周期函数一致, 即会阻塞渲染

3. useDebugValue




