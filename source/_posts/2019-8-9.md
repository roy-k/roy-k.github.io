---
title: react.memo
date: 2019-08-09 16:51:16
tags: [react, memo]
---

`react.memo` 是一个高阶组件, 用于组件缓存, 避免不必要的渲染(针对合适的地方)

## 什么时候使用

1. 无副作用的函数式组件

    传入同样的props, 输出不变

2. 频繁的渲染

3. 组件周期渲染中, 通常向下传递同样的props

4. 含有大量的ui元素

<!-- more -->

## 如何使用

```js
export function Movie({ title, releaseDate }) {
  return (
    <div>
      <div>Movie title: {title}</div>
      <div>Release date: {releaseDate}</div>
    </div>
  );
}

// 包装组件
export const MemoizedMovie = React.memo(Movie);
```

```js
// 第一次渲染, 无差异.
<MemoizedMovie
  movieTitle="Heat"
  releaseDate="December 15, 1995"
/>

// 组件树更新时, 比较props是否发生变化
// 如果不变, 阻止重新渲染
<MemoizedMovie
  movieTitle="Heat"
  releaseDate="December 15, 1995"
/>
```

还可以传入第二个参数做为比较函数

```js
// React.memo(Component, [areEqual(prevProps, nextProps)]);

function moviePropsAreEqual(prevMovie, nextMovie) {
  return prevMovie.title === nextMovie.title
    && prevMovie.releaseDate === nextMovie.releaseDate;
}

const MemoizedMovie2 = React.memo(Movie, moviePropsAreEqual);
```

**频繁渲染实例**

```js
<MovieViewsRealtime
  views={0}
  title="Forrest Gump"
  releaseDate="June 23, 1994"
/>

<MovieViewsRealtime
  views={10}
  title="Forrest Gump"
  releaseDate="June 23, 1994"
/>

// 只有views不停的变化, 此时其他元素就可以做缓存
<MovieViewsRealtime
  views={25}
  title="Forrest Gump"
  releaseDate="June 23, 1994"
/>

// etc
```

```js
function MovieViewsRealtime({ title, releaseDate, views }) {
  return (
    <div>
      <MemoizedMovie title={title} releaseDate={releaseDate} />
      Movie views: {views}
    </div>
  )
}
```

## 避免使用的情形

如果组件属性每次都不一样, 即每次都无法使用缓存


## todo

性能比较图

## 参考

[Use React.memo() wisely](https://dmitripavlutin.com/use-react-memo-wisely/)